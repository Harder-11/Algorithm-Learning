#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int INF = 0x3f3f3f3f;
const int N = 2000005;
const int mod = 1e9 + 7;

/*
基环树
一个图包含n个点,n条边,并且图中只存在一个环,这样的图就被称为基环树(环套树)
基环树比树多一条边,从而形成了一个环,基环树可以看做以环点为根的一棵棵子树构成

基环树有三类:(1)无向树 (2)外向树(没个点只有一条出边) (3)内向树(每个点只有一条入边) 
基本思想:1.深搜找环 2.断环成树,对树进行深搜计算

例题:骑士(p2607)
Z国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。
他们劫富济贫，惩恶扬善，受到社会各界的赞扬。
最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。
战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。
于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。
骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。
每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的
战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！
国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，
使得军团内没有矛盾的两人(不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况)
并且，使得这支骑士军团最具有战斗力。
为了描述战斗力,我们将骑士按照1到n标号,给每个骑士一个战斗力估计,一个军团的战斗力为所有骑士的
战斗力之和

输入:
第一行包含一个整数n，描述骑士团的人数。
接下来n行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。

思路:转化为n个点n条边,每个点有权值,有边相连的两个点只能二选一(类似打家劫舍),选取最大的点权之和
1.建图之后,实际就是一个基环树森林
2.对于每棵基环树,先断开环上的任意一条边,对两个端点分别作一次树型dp,两次答案取更大值
3.然后累加每棵基环树的最大值即可
*/

struct edge {
    int to,nxt;
} e[N];
int head[N],w[N],idx;
int r1,r2,vis[N];
ll f[N][2],sum;

void add(int u,int v){
    e[++idx] = {v,head[u]};
    head[u] = idx;
}

//找两个根
void find(int u,int rt){
    vis[u] = 1;
    for(int i = head[u];i;i = e[i].nxt){
        int v = e[i].to;
        //绕了一圈回到rt点了
        if(v == rt){
            r1 = u;
            r2 = v;
            return;
        }
        if(vis[v]) continue;
        find(v,rt);
    }
}

ll dfs(int u,int rt){
    f[u][0] = 0;
    f[u][1] = w[u];
    for(int i = head[u];i;i = e[i].nxt){
        int v = e[i].to;
        //保证遍历走的是一棵树,否则不满足树型dp了
        if(v == rt){
            continue;
        }
        dfs(v,rt);
        f[u][0] += max(f[v][0],f[v][1]);
        f[u][1] += f[v][0];
    }
    return f[u][0];
}

void solve(){
    int n;
    cin >> n;
    for(int v = 1,u;v <= n;v++){
        cin >> w[v] >> u;
        add(u,v);
    }
    for(int i = 1;i <= n;i++){
        if(!vis[i]){
            r1 = r2 = 0;
            find(i,i);
            //如果r1在环上,那么此时r1就不是0,执行if中的语句
            if(r1){
                ll res1 = dfs(r1,r1);
                ll res2 = dfs(r2,r2);
                sum += max(res1,res2);
            }
        }
    }
    cout << sum << '\n';
}

int main(){
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}